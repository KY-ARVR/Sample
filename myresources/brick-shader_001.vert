/* 10.05.2015
 * "Orange Book - OpenGL Shading Language 2nd Edition", PDF-page 155-166
 * "Orange Book - OpenGL Shading Language 2nd Edition", PDF-page 209 (example for setting the uniform variables)
 */

#version 120

/* To illustrate the use of uniform variables, the position of the
 * only light source is not read from "gl_LightSource", but from a
 * uniform variable.
 */
uniform vec3 LightPosition;

// The contribution from the specular reflection.
const float SpecularContribution = 0.3;
// The contribution from the diffuse reflection.
const float DiffuseContribution  = 1.0 - SpecularContribution;

// The computed light intensity for the fragment shader.
varying float LightIntensity;
/* Called "MCposition" in the source.
 * The x- and y-coordinates of the incoming vertex position
 * ("gl_Vertex") to be passed to the fragment shader. The vertex
 * position is, by definition, in modeling coordinates.
 * This ensures, that the brick pattern remains constant with respect
 * to the surface of the object, no matter how the object is moved.
 * Also this guarantees, that the brick pattern remains constant with
 * respect to the surface of the objects, no matter what the viewing
 * position.
 */
varying vec2  PositionInModelCoordinates;


void main (void)
{
  /* Called "ecPosition" in the source.
   * Holds the eye coordinate position of the incoming vertex by
   * transforming the vertex position ("gl_Vertex") by the current
   * modelview matrix ("gl_ModelViewMatrix").
   */
  vec3  eyeCoordinatePositionOfVertex;
  /* Called "tnorm" in the source.
   * Stores the transformed normal, generated by transforming the
   * incoming surface normal ("gl_Normal") by the current OpenGL
   * normal transformation matrix ("gl_NormalMatrix").
   * The resulting vector is then normalized.
   */
  vec3  transformedSurfaceNormal;
  /* Called "lightVec" in the source.
   * Stores the vector from the object's surface to the light source.
   * As both should be in eye coordinates, the "LightPosition" must be
   * passed from the application to the shader in eye coordinates.
   * The light direction vector is calculated by subtracting the
   * object position from the light position and normalizing the
   * resulting vector.
   */
  vec3  vectorFromSurfaceToLight;
  /* Called "reflectVec" in the source.
   * Holds a reflection vector at the surface of the object.
   * To compute this vector, we need the "reflect(...)" function. This
   * function requires the incident vector, that is, the direction
   * (vector) FROM THE LIGHT TO THE SURFACE; but we have defined the
   * vector FROM THE SURFACE TO THE LIGHT with
   * "vectorFromSurfaceToLight". To change the direction, we simply
   * negate the "vectorFromSurfaceToLight" vector:
   *   -vectorFromSurfaceToLight
   * As both vectors, "vectorFromSurfaceToLight" and
   * "transformedSurfaceNormal" are unit vectors, the resulting vector
   * is a unit vector, too.
   */
  vec3  reflectionVector;
  /* Called "viewVec" in the source.
   * The unit vector in direction from the vertex position in eye
   * coordinates to the viewer (eye).
   * With "eyeCoordinatePositionOfVertex" we have a vector
   * FROM THE EYE POSITION TO THE SURFACE POINT, but we need a
   * normalized vector from the SURFACE POINT TO THE EYE POSITION.
   * As, by definition, the viewing position is at the origin
   * P(0, 0, 0) in the eye coordinate system, we yield this vector
   * by negating the "eyeCoordinatePositionOfVertex" and normalizing
   * it:
   *   vector_from_light_to_surface = -vectorFromSurfaceToLight
   */
  vec3  vectorFromPosInEyeCoordsToView;
  /* Called "diffuse" in the source.
   * The modeling of diffuse reflection is based on incident light being
   * scattered in all directions. It is stronget when the light
   * direction vector and surface normal are coincident. As the
   * difference between their angle increases to 90° degrees, the
   * diffuse reflection drops off to zero.
   * As both light vector ("vectorFromSurfaceToLight") and surface
   * normal ("transformedSurfaceNormal") have been normalized (their
   * length has become equal to one), their dot product will return
   * the cosine of the angle between them.
   * Using the "max()" function, we guarantee that the diffuse
   * contribution is at least zero, if the angle is greater than 90°;
   * thus there is no diffuse contribution if the light is behind the
   * object.
   */
  float diffuseReflection;
  /* Called "spec" in the source.
   * The specular reflection is only calculated, if the angle between
   * the reflected light vector ("reflectionVector") and the
   * view vector ("vectorFromPosInEyeCoordsToView") is less than 90°, as
   * otherwise the light source is behind the object, so a specular
   * reflection is not realistic. Thus the specular reflection only
   * has a value other than zero, if the diffuse value is greater than
   * zero.
   * To "sharpen" the highlight, an arbitrary exponent value of 16.0
   * is chosen.
   */
  float specularReflection;
  
  eyeCoordinatePositionOfVertex  = vec3      (gl_ModelViewMatrix * gl_Vertex);
  transformedSurfaceNormal       = normalize (gl_NormalMatrix * gl_Normal);
  vectorFromSurfaceToLight       = normalize (LightPosition - eyeCoordinatePositionOfVertex);
  reflectionVector               = reflect   (-vectorFromSurfaceToLight,
                                               transformedSurfaceNormal);
  vectorFromPosInEyeCoordsToView = normalize (-eyeCoordinatePositionOfVertex);
  
  diffuseReflection              = dot (vectorFromSurfaceToLight,
                                        transformedSurfaceNormal);
  diffuseReflection              = max (diffuseReflection, 0.0);
  specularReflection             = 0.0;
  
  if (diffuseReflection > 0.0)
  {
    specularReflection = dot (reflectionVector,
                              vectorFromPosInEyeCoordsToView);
    specularReflection = max (specularReflection,  0.0);
    specularReflection = pow (specularReflection, 16.0);
  }
  
  LightIntensity           = DiffuseContribution  * diffuseReflection +
                             SpecularContribution * specularReflection;
  PositionInModelCoordinates = gl_Vertex.xy;
  
  /* We compute the homogeneous vertex position by transforming the
   * incoming vertex value by the current modelview-projection matrix.
   */
  gl_Position                = ftransform ();
}
